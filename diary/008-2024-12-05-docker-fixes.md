# Diary Entry 008 - Docker Environment Fixes

**Date:** 2024-12-05
**Feature:** Fix Docker development environment and add Docker testing

## Summary

Fixed multiple issues with the Docker development environment that were causing "Failed to fetch" errors when running the app via Docker. Also added a dedicated Docker smoke test script to catch these issues in the future.

## The Problem

When running `./scripts/dev-all.sh`, the frontend showed "Failed to fetch" errors on the courses page. The backend was healthy, but the browser couldn't reach the GraphQL endpoint.

## My Thinking

The root cause was a misunderstanding of how Docker networking works with browser-based apps:

1. The `docker-compose.yml` had `VITE_GRAPHQL_ENDPOINT=http://backend:8082/graphql`
2. This works for server-to-server calls within the Docker network
3. BUT the browser runs on the host machine, not inside Docker
4. The browser can't resolve `backend:8082` - it needs `localhost:8082`

This is a common pitfall: Vite injects environment variables at build/dev time, and the resulting JavaScript runs in the browser, which has no access to Docker's internal DNS.

## Why Testing Didn't Catch It

The E2E tests (Playwright) run services directly via `pnpm dev`, not via Docker. They use the local filesystem and localhost networking, so they never exercise the Docker configuration.

This exposed a gap: we were testing the app logic but not the Docker deployment configuration.

## Fixes Applied

### 1. Frontend `.env.example` file
Created `frontend/.env.example` as a template (`.env` is gitignored):
```
VITE_GRAPHQL_ENDPOINT=http://localhost:8082/graphql
```
Developers should copy this to `.env` when setting up.

### 2. Docker Compose Scripts
- Changed `docker-compose` to `docker compose` (V2 syntax)
- Updated `dev-all.sh` and `stop-all.sh`

### 3. Backend Dockerfile
- Updated to Go 1.25-alpine (from 1.22)
- Fixed air package path to `github.com/air-verse/air@latest`

### 4. Health Check Configuration
Added `start_period: 30s` to backend healthcheck to give it time to start before health checks begin failing:
```yaml
healthcheck:
  test: ["CMD", "wget", "-qO-", "http://localhost:8082/health"]
  interval: 10s
  timeout: 5s
  retries: 5
  start_period: 30s
```

### 5. dev-all.sh Improvements
Added automatic health verification:
- Waits up to 60s for backend health
- Waits up to 30s for frontend
- Exits with error if either fails
- Shows clear success/failure messages

### 6. New Docker Test Script
Created `./scripts/test-docker.sh` that:
- Builds and starts Docker containers
- Verifies health checks pass
- Tests GraphQL endpoint accessibility
- Tests CORS configuration
- Provides clear pass/fail output

## Trade-offs

**Pros:**
- Docker environment now works correctly
- Health verification prevents false "success" messages
- Dedicated Docker test catches deployment issues early

**Cons:**
- Two test scripts to run (E2E + Docker)
- Slight complexity in having both `.env` file and docker-compose env vars

## Documentation Updates

Updated both `ai-new-feature.md` and `infrastructure.md` to:
- List `test-docker.sh` in available scripts
- Require testing BOTH environments (E2E + Docker)
- Added version requirements table with latest versions

## Lessons Learned

1. **Browser vs Server context matters**: Environment variables for browser-side code need to use host-accessible URLs, not Docker network names.

2. **Test what you deploy**: If you deploy with Docker, you need Docker-specific tests.

3. **Health checks need grace periods**: Containers need time to start before health checks should be considered failures.

4. **Don't declare success prematurely**: The script should verify services are actually healthy, not just "started".
