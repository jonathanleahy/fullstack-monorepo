{
  "query": "mutation CreateCourse($input: CreateLibraryCourseInput!) { createLibraryCourse(input: $input) { id title } }",
  "variables": {
    "input": {
      "title": "Hexagonal Architecture: Building Maintainable Software",
      "description": "Master the Ports and Adapters pattern from the ground up. This comprehensive course takes you from 'what is this weird hexagon thing?' to confidently architecting enterprise applications. You'll learn through real examples, common mistakes to avoid, and hands-on exercises. By the end, you'll understand why companies like Netflix, Spotify, and countless startups use this pattern - and how to apply it in your own projects.",
      "author": "Architecture Academy",
      "difficulty": "INTERMEDIATE",
      "estimatedHours": 12,
      "tags": ["architecture", "design-patterns", "clean-code", "golang", "software-design", "ports-and-adapters", "clean-architecture", "ddd"],
      "lessons": [
        {
          "title": "The Problem: Why Traditional Architecture Fails",
          "order": 1,
          "content": "# The Problem: Why Traditional Architecture Fails\n\nBefore we dive into Hexagonal Architecture, let's understand the pain it solves. If you've never felt this pain, you might not appreciate the solution!\n\n## The Typical Project Journey\n\n**Month 1:** Everything is great! You're building fast, shipping features.\n\n**Month 6:** \"Why is this test taking 30 seconds? Oh, it's hitting the real database.\"\n\n**Month 12:** \"We need to switch from PostgreSQL to MongoDB.\" *Team collectively sighs*\n\n**Month 18:** \"The framework we chose is no longer maintained.\" *Panic ensues*\n\n## A Real Story\n\nImagine you're building an e-commerce platform. You start simple:\n\n```go\n// Seems reasonable at first...\nfunc CreateOrder(w http.ResponseWriter, r *http.Request) {\n    var order Order\n    json.NewDecoder(r.Body).Decode(&order)\n    \n    // Validate\n    if order.Total < 0 {\n        http.Error(w, \"Invalid total\", 400)\n        return\n    }\n    \n    // Save to database\n    db.Exec(\"INSERT INTO orders...\")\n    \n    // Send email\n    smtp.Send(order.CustomerEmail, \"Order confirmed!\")\n    \n    // Notify warehouse\n    http.Post(\"http://warehouse-api/orders\", ...)\n    \n    json.NewEncoder(w).Encode(order)\n}\n```\n\n### What's Wrong Here?\n\n1. **Testing is painful** - You need a real database, SMTP server, and warehouse API\n2. **Changes cascade** - Switching email providers means changing business logic\n3. **Everything is coupled** - HTTP, database, email, external APIs all mixed together\n4. **No clear boundaries** - Where does \"order creation\" logic live?\n\n## The Coupling Problem Visualized\n\n```\n┌─────────────────────────────────────────────────────┐\n│                   Your Code                         │\n│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌────────┐ │\n│  │ HTTP    │──│ Business│──│ Database│──│ Email  │ │\n│  │ Handler │  │ Logic   │  │ Queries │  │ Client │ │\n│  └─────────┘  └─────────┘  └─────────┘  └────────┘ │\n│       │            │            │            │      │\n│       ▼            ▼            ▼            ▼      │\n│    chi/gin    Your Rules   PostgreSQL   SendGrid   │\n└─────────────────────────────────────────────────────┘\n\nProblem: Everything depends on everything!\n```\n\n## The Cost of Coupling\n\n| Problem | Business Impact |\n|---------|----------------|\n| Slow tests | Developers wait, ship less |\n| Hard to change databases | Vendor lock-in |\n| Framework upgrades break everything | Security vulnerabilities linger |\n| Can't test business logic in isolation | Bugs slip through |\n\n## What We Need\n\nAn architecture where:\n- Business logic is **isolated** from infrastructure\n- Tests run in **milliseconds** without external services\n- We can **swap** databases, frameworks, or APIs easily\n- The code **communicates its intent** clearly\n\nThis is exactly what Hexagonal Architecture provides. Let's learn how!"
        },
        {
          "title": "The Big Picture: What is Hexagonal Architecture?",
          "order": 2,
          "content": "# The Big Picture: What is Hexagonal Architecture?\n\nHexagonal Architecture was invented by Alistair Cockburn in 2005. The name comes from the hexagonal diagrams he drew, but the shape isn't important - the **concepts** are.\n\n## The Core Idea (In One Sentence)\n\n> **Your business logic should not know or care about the outside world.**\n\nThat's it. Everything else flows from this principle.\n\n## The Hexagon Metaphor\n\nImagine your application as a fortress:\n\n```\n                    ┌─────────────────┐\n                    │   Web Browser   │\n                    └────────┬────────┘\n                             │\n                    ┌────────▼────────┐\n                    │  HTTP Adapter   │\n                    └────────┬────────┘\n                             │\n          ┌──────────────────┼──────────────────┐\n          │                  │                  │\n          │    ┌─────────────▼─────────────┐    │\n          │    │         PORTS             │    │\n          │    │   (Interfaces/Contracts)  │    │\n          │    └─────────────┬─────────────┘    │\n          │                  │                  │\n          │    ┌─────────────▼─────────────┐    │\n          │    │                           │    │\n          │    │    DOMAIN / BUSINESS      │    │\n          │    │         LOGIC             │    │\n          │    │                           │    │\n          │    │   (Pure, No Dependencies) │    │\n          │    │                           │    │\n          │    └─────────────┬─────────────┘    │\n          │                  │                  │\n          │    ┌─────────────▼─────────────┐    │\n          │    │         PORTS             │    │\n          │    │   (Interfaces/Contracts)  │    │\n          │    └─────────────┬─────────────┘    │\n          │                  │                  │\n          └──────────────────┼──────────────────┘\n                             │\n                    ┌────────▼────────┐\n                    │  Database       │\n                    │  Adapter        │\n                    └────────┬────────┘\n                             │\n                    ┌────────▼────────┐\n                    │   PostgreSQL    │\n                    └─────────────────┘\n```\n\n## The Three Layers\n\n### 1. Domain (The Core)\nThis is your **business logic** - the reason your software exists:\n- What does it mean to \"create an order\"?\n- What rules must a \"user\" follow?\n- How do you calculate shipping costs?\n\n**Key Rule:** The domain has NO dependencies on external libraries or frameworks.\n\n### 2. Ports (The Gates)\nPorts are **interfaces** that define how the outside world interacts with your domain:\n- \"I need to save a user somewhere\"\n- \"Someone needs to be able to create orders\"\n- \"I need to send notifications somehow\"\n\n**Key Rule:** Ports don't say HOW, they say WHAT.\n\n### 3. Adapters (The Bridges)\nAdapters are **implementations** that connect real-world technologies to your ports:\n- \"I'll save users in PostgreSQL\"\n- \"I'll expose order creation via REST API\"\n- \"I'll send notifications via SendGrid\"\n\n**Key Rule:** Adapters can be swapped without changing the domain.\n\n## Why \"Hexagonal\"?\n\nThe hexagon shape implies **many sides** - many ways to connect to your application:\n- Web UI\n- Mobile app\n- CLI\n- REST API\n- GraphQL\n- Message queues\n- Scheduled jobs\n\nAll connect through ports and adapters, none directly to your business logic.\n\n## Other Names for This Pattern\n\nYou might hear these terms - they're all related:\n- **Ports and Adapters** (same thing, clearer name)\n- **Clean Architecture** (Uncle Bob's version)\n- **Onion Architecture** (similar, layers like an onion)\n\nThe core principle is the same: **protect your business logic from the outside world**."
        },
        {
          "title": "Understanding Ports: The Contracts",
          "order": 3,
          "content": "# Understanding Ports: The Contracts\n\nPorts are the **interfaces** that define how your application core communicates. Think of them as contracts or agreements.\n\n## An Analogy: Electrical Outlets\n\nConsider a wall outlet:\n- The outlet doesn't care what you plug into it (phone charger, lamp, laptop)\n- Your devices don't care how electricity is generated (coal, solar, nuclear)\n- The **interface** (the outlet shape) is the contract\n\nIn code:\n```go\n// This is like an electrical outlet - a standard interface\ntype UserRepository interface {\n    Save(ctx context.Context, user *User) error\n    FindByID(ctx context.Context, id string) (*User, error)\n}\n```\n\n## Two Types of Ports\n\n### 1. Driving Ports (Primary / Inbound)\n\n**Who uses them:** The outside world\n**What they do:** Define what your application CAN DO\n\nThink: \"What services does my application offer?\"\n\n```go\n// This port says: \"My application can manage users\"\ntype UserService interface {\n    // Create a new user (returns the user with generated ID)\n    CreateUser(ctx context.Context, input CreateUserInput) (*User, error)\n    \n    // Get a user by their ID\n    GetUser(ctx context.Context, id string) (*User, error)\n    \n    // Update user information\n    UpdateUser(ctx context.Context, id string, input UpdateUserInput) (*User, error)\n    \n    // Remove a user from the system\n    DeleteUser(ctx context.Context, id string) error\n    \n    // List users with filtering and pagination\n    ListUsers(ctx context.Context, filter UserFilter) (*UserList, error)\n}\n```\n\n### 2. Driven Ports (Secondary / Outbound)\n\n**Who uses them:** Your application\n**What they do:** Define what your application NEEDS\n\nThink: \"What external capabilities does my application require?\"\n\n```go\n// This port says: \"I need to store users somewhere\"\ntype UserRepository interface {\n    Save(ctx context.Context, user *User) error\n    FindByID(ctx context.Context, id string) (*User, error)\n    FindByEmail(ctx context.Context, email string) (*User, error)\n    Delete(ctx context.Context, id string) error\n    List(ctx context.Context, filter UserFilter) ([]*User, error)\n}\n\n// This port says: \"I need to send emails somehow\"\ntype EmailSender interface {\n    SendWelcomeEmail(ctx context.Context, to string, userName string) error\n    SendPasswordReset(ctx context.Context, to string, resetLink string) error\n}\n\n// This port says: \"I need to process payments somehow\"\ntype PaymentProcessor interface {\n    Charge(ctx context.Context, amount Money, paymentMethod PaymentMethod) (*Payment, error)\n    Refund(ctx context.Context, paymentID string, amount Money) error\n}\n```\n\n## Port Design Guidelines\n\n### 1. Use Domain Language\n\n```go\n// ❌ Bad: Technical/database language\ntype UserDAO interface {\n    Insert(row UserRow) error\n    SelectByPK(pk int64) (*UserRow, error)\n}\n\n// ✅ Good: Domain language\ntype UserRepository interface {\n    Save(ctx context.Context, user *User) error\n    FindByID(ctx context.Context, id string) (*User, error)\n}\n```\n\n### 2. Keep Ports Focused\n\n```go\n// ❌ Bad: God interface\ntype EverythingService interface {\n    CreateUser(...) error\n    CreateOrder(...) error\n    SendEmail(...) error\n    ProcessPayment(...) error\n    GenerateReport(...) error\n}\n\n// ✅ Good: Focused interfaces\ntype UserService interface { ... }\ntype OrderService interface { ... }\ntype EmailSender interface { ... }\n```\n\n### 3. Don't Leak Infrastructure\n\n```go\n// ❌ Bad: Leaks SQL concepts\ntype UserRepository interface {\n    Query(sql string, args ...interface{}) (*sql.Rows, error)\n}\n\n// ❌ Bad: Leaks HTTP concepts\ntype UserService interface {\n    HandleRequest(w http.ResponseWriter, r *http.Request)\n}\n\n// ✅ Good: Pure domain concepts\ntype UserRepository interface {\n    FindByID(ctx context.Context, id string) (*User, error)\n}\n```\n\n## Why Ports Matter\n\n| Without Ports | With Ports |\n|---------------|------------|\n| Business logic calls database directly | Business logic calls interface |\n| Changing database = changing business logic | Changing database = new adapter |\n| Tests need real database | Tests use mock adapter |\n| Tightly coupled | Loosely coupled |"
        },
        {
          "title": "Understanding Adapters: The Implementations",
          "order": 4,
          "content": "# Understanding Adapters: The Implementations\n\nIf ports are the contracts, adapters are the **concrete implementations** that fulfill those contracts.\n\n## An Analogy: Power Adapters\n\nWhen you travel internationally, you use a power adapter:\n- Your laptop expects a certain plug shape (the \"port\")\n- Different countries have different outlets\n- The adapter **translates** between them\n\nIn software, adapters translate between your domain and the outside world.\n\n## Two Types of Adapters\n\n### 1. Driving Adapters (Primary / Inbound)\n\n**What they do:** Receive requests from the outside world and translate them into domain calls.\n\n**Examples:**\n- HTTP handlers (REST APIs)\n- GraphQL resolvers\n- CLI commands\n- gRPC servers\n- Message queue consumers\n- Scheduled job runners\n\n```go\n// HTTP Adapter - translates HTTP to domain calls\ntype UserHTTPHandler struct {\n    userService ports.UserService  // The driving port\n}\n\nfunc NewUserHTTPHandler(service ports.UserService) *UserHTTPHandler {\n    return &UserHTTPHandler{userService: service}\n}\n\nfunc (h *UserHTTPHandler) CreateUser(w http.ResponseWriter, r *http.Request) {\n    // 1. TRANSLATE: HTTP request → Domain input\n    var req CreateUserRequest\n    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n        http.Error(w, \"Invalid JSON\", http.StatusBadRequest)\n        return\n    }\n    \n    // 2. VALIDATE: HTTP-specific validation\n    if req.Email == \"\" {\n        http.Error(w, \"Email required\", http.StatusBadRequest)\n        return\n    }\n    \n    // 3. CALL: Domain service\n    user, err := h.userService.CreateUser(r.Context(), ports.CreateUserInput{\n        Name:  req.Name,\n        Email: req.Email,\n    })\n    \n    // 4. TRANSLATE: Domain result → HTTP response\n    if err != nil {\n        switch {\n        case errors.Is(err, entities.ErrEmailTaken):\n            http.Error(w, \"Email already exists\", http.StatusConflict)\n        default:\n            http.Error(w, \"Internal error\", http.StatusInternalServerError)\n        }\n        return\n    }\n    \n    w.WriteHeader(http.StatusCreated)\n    json.NewEncoder(w).Encode(toUserResponse(user))\n}\n```\n\n### 2. Driven Adapters (Secondary / Outbound)\n\n**What they do:** Implement the interfaces your domain needs, connecting to real infrastructure.\n\n**Examples:**\n- Database repositories (PostgreSQL, MongoDB, SQLite)\n- Email services (SendGrid, SES, SMTP)\n- Payment gateways (Stripe, PayPal)\n- External API clients\n- File storage (S3, local filesystem)\n- Cache implementations (Redis, in-memory)\n\n```go\n// SQLite Adapter - implements UserRepository port\ntype SQLiteUserRepository struct {\n    db *sql.DB\n}\n\nfunc NewSQLiteUserRepository(db *sql.DB) *SQLiteUserRepository {\n    return &SQLiteUserRepository{db: db}\n}\n\nfunc (r *SQLiteUserRepository) Save(ctx context.Context, user *entities.User) error {\n    // TRANSLATE: Domain entity → SQL\n    query := `\n        INSERT INTO users (id, name, email, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?)\n        ON CONFLICT(id) DO UPDATE SET\n            name = excluded.name,\n            email = excluded.email,\n            updated_at = excluded.updated_at\n    `\n    _, err := r.db.ExecContext(ctx, query,\n        user.ID,\n        user.Name,\n        user.Email,\n        user.CreatedAt,\n        user.UpdatedAt,\n    )\n    return err\n}\n\nfunc (r *SQLiteUserRepository) FindByID(ctx context.Context, id string) (*entities.User, error) {\n    query := `SELECT id, name, email, created_at, updated_at FROM users WHERE id = ?`\n    \n    var user entities.User\n    err := r.db.QueryRowContext(ctx, query, id).Scan(\n        &user.ID,\n        &user.Name,\n        &user.Email,\n        &user.CreatedAt,\n        &user.UpdatedAt,\n    )\n    \n    // TRANSLATE: SQL error → Domain error\n    if err == sql.ErrNoRows {\n        return nil, entities.ErrUserNotFound\n    }\n    if err != nil {\n        return nil, fmt.Errorf(\"database error: %w\", err)\n    }\n    \n    return &user, nil\n}\n```\n\n## Adapter Responsibilities\n\n| Do This | Don't Do This |\n|---------|---------------|\n| Translate data formats | Contain business logic |\n| Handle infrastructure errors | Make business decisions |\n| Map to/from domain types | Validate business rules |\n| Deal with protocols | Know about other adapters |\n\n## The Power of Adapters: Easy Swapping\n\n```go\n// Want to switch from SQLite to PostgreSQL?\n// Just create a new adapter:\n\ntype PostgresUserRepository struct {\n    pool *pgxpool.Pool\n}\n\nfunc (r *PostgresUserRepository) Save(ctx context.Context, user *entities.User) error {\n    // PostgreSQL-specific implementation\n    // Domain doesn't know or care!\n}\n\n// In main.go, just swap the adapter:\n// OLD: userRepo := sqlite.NewUserRepository(sqliteDB)\n// NEW: userRepo := postgres.NewUserRepository(pgPool)\n```"
        },
        {
          "title": "The Domain Layer: Your Business Heart",
          "order": 5,
          "content": "# The Domain Layer: Your Business Heart\n\nThe domain layer is the **most important** part of your application. It's where your business lives.\n\n## What Belongs in the Domain?\n\n### 1. Entities (Business Objects)\n\nEntities are objects with **identity** and **behavior**:\n\n```go\npackage entities\n\nimport (\n    \"errors\"\n    \"regexp\"\n    \"time\"\n    \n    \"github.com/google/uuid\"\n)\n\n// Domain errors - these are part of your business language\nvar (\n    ErrInvalidEmail    = errors.New(\"invalid email format\")\n    ErrNameTooShort    = errors.New(\"name must be at least 2 characters\")\n    ErrUserNotFound    = errors.New(\"user not found\")\n    ErrEmailTaken      = errors.New(\"email already registered\")\n)\n\n// User is a domain entity\ntype User struct {\n    ID        string\n    Name      string\n    Email     string\n    CreatedAt time.Time\n    UpdatedAt time.Time\n}\n\n// NewUser is a factory function - enforces business rules at creation\nfunc NewUser(name, email string) (*User, error) {\n    // Business rule: name must be at least 2 characters\n    if len(name) < 2 {\n        return nil, ErrNameTooShort\n    }\n    \n    // Business rule: email must be valid format\n    if !isValidEmail(email) {\n        return nil, ErrInvalidEmail\n    }\n    \n    now := time.Now()\n    return &User{\n        ID:        uuid.New().String(),\n        Name:      name,\n        Email:     email,\n        CreatedAt: now,\n        UpdatedAt: now,\n    }, nil\n}\n\n// UpdateEmail changes the user's email with validation\nfunc (u *User) UpdateEmail(email string) error {\n    if !isValidEmail(email) {\n        return ErrInvalidEmail\n    }\n    u.Email = email\n    u.UpdatedAt = time.Now()\n    return nil\n}\n\n// UpdateName changes the user's name with validation\nfunc (u *User) UpdateName(name string) error {\n    if len(name) < 2 {\n        return ErrNameTooShort\n    }\n    u.Name = name\n    u.UpdatedAt = time.Now()\n    return nil\n}\n\n// Helper - also part of domain, but private\nvar emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`)\n\nfunc isValidEmail(email string) bool {\n    return emailRegex.MatchString(email)\n}\n```\n\n### 2. Value Objects (Immutable Values)\n\nValue objects don't have identity - they're defined by their values:\n\n```go\n// Money is a value object - defined entirely by amount and currency\ntype Money struct {\n    amount   int64  // cents to avoid floating point issues\n    currency string\n}\n\nfunc NewMoney(amount int64, currency string) (Money, error) {\n    if amount < 0 {\n        return Money{}, errors.New(\"amount cannot be negative\")\n    }\n    if currency == \"\" {\n        return Money{}, errors.New(\"currency required\")\n    }\n    return Money{amount: amount, currency: currency}, nil\n}\n\nfunc (m Money) Add(other Money) (Money, error) {\n    if m.currency != other.currency {\n        return Money{}, errors.New(\"cannot add different currencies\")\n    }\n    return Money{amount: m.amount + other.amount, currency: m.currency}, nil\n}\n\nfunc (m Money) Amount() int64   { return m.amount }\nfunc (m Money) Currency() string { return m.currency }\n```\n\n### 3. Domain Services\n\nLogic that doesn't belong to a single entity:\n\n```go\n// AuthService handles authentication logic\ntype AuthService struct {\n    jwtSecret     string\n    tokenDuration time.Duration\n}\n\nfunc NewAuthService(secret string) *AuthService {\n    return &AuthService{\n        jwtSecret:     secret,\n        tokenDuration: 24 * time.Hour,\n    }\n}\n\nfunc (s *AuthService) GenerateToken(user *User) (string, error) {\n    claims := jwt.MapClaims{\n        \"user_id\": user.ID,\n        \"email\":   user.Email,\n        \"exp\":     time.Now().Add(s.tokenDuration).Unix(),\n        \"iat\":     time.Now().Unix(),\n    }\n    \n    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n    return token.SignedString([]byte(s.jwtSecret))\n}\n\nfunc (s *AuthService) ValidateToken(tokenString string) (*TokenClaims, error) {\n    // Pure validation logic - no HTTP, no database\n}\n```\n\n## The Golden Rules of the Domain\n\n### Rule 1: No Framework Dependencies\n\n```go\n// ❌ BAD: Domain depends on web framework\nimport \"github.com/gin-gonic/gin\"\n\nfunc (u *User) HandleRequest(c *gin.Context) { ... }\n\n// ✅ GOOD: Domain is pure Go\nfunc (u *User) UpdateEmail(email string) error { ... }\n```\n\n### Rule 2: No Infrastructure Concerns\n\n```go\n// ❌ BAD: Domain knows about SQL\nfunc (u *User) Save(db *sql.DB) error {\n    db.Exec(\"INSERT INTO users...\")\n}\n\n// ✅ GOOD: Domain doesn't know how it's persisted\n// Persistence is handled by repository adapters\n```\n\n### Rule 3: Express Business Rules Clearly\n\n```go\n// ❌ BAD: Magic numbers, unclear rules\nif len(password) < 8 {\n    return err\n}\n\n// ✅ GOOD: Named constants, clear rules\nconst MinPasswordLength = 8\n\nvar ErrPasswordTooShort = fmt.Errorf(\n    \"password must be at least %d characters\", \n    MinPasswordLength,\n)\n\nfunc ValidatePassword(password string) error {\n    if len(password) < MinPasswordLength {\n        return ErrPasswordTooShort\n    }\n    return nil\n}\n```"
        },
        {
          "title": "Use Cases: Orchestrating Business Operations",
          "order": 6,
          "content": "# Use Cases: Orchestrating Business Operations\n\nUse cases (also called \"application services\" or \"interactors\") orchestrate the flow of data between ports and the domain.\n\n## What's a Use Case?\n\nA use case represents a **single business operation** that a user or system can perform:\n- \"Create a new user account\"\n- \"Place an order\"\n- \"Transfer money between accounts\"\n\n## Anatomy of a Use Case\n\n```go\npackage usecases\n\nimport (\n    \"context\"\n    \"log/slog\"\n    \n    \"myapp/domain/entities\"\n    \"myapp/domain/repositories\"\n    \"myapp/domain/services\"\n    \"myapp/application/ports\"\n)\n\n// UserUseCase implements the UserService driving port\ntype UserUseCase struct {\n    // Dependencies injected via constructor\n    userRepo    repositories.UserRepository  // driven port\n    emailSender repositories.EmailSender     // driven port\n    authService *services.AuthService        // domain service\n    logger      *slog.Logger\n}\n\n// NewUserUseCase creates a new use case with its dependencies\nfunc NewUserUseCase(\n    userRepo repositories.UserRepository,\n    emailSender repositories.EmailSender,\n    authService *services.AuthService,\n    logger *slog.Logger,\n) *UserUseCase {\n    return &UserUseCase{\n        userRepo:    userRepo,\n        emailSender: emailSender,\n        authService: authService,\n        logger:      logger,\n    }\n}\n\n// CreateUser implements ports.UserService\nfunc (uc *UserUseCase) CreateUser(\n    ctx context.Context,\n    input ports.CreateUserInput,\n) (*entities.User, error) {\n    // 1. LOG: Operation started\n    uc.logger.Info(\"creating user\", \"email\", input.Email)\n    \n    // 2. CHECK: Business rule - email must be unique\n    existing, err := uc.userRepo.FindByEmail(ctx, input.Email)\n    if err != nil && err != entities.ErrUserNotFound {\n        return nil, fmt.Errorf(\"checking email: %w\", err)\n    }\n    if existing != nil {\n        return nil, entities.ErrEmailTaken\n    }\n    \n    // 3. CREATE: Domain entity (validation happens here)\n    user, err := entities.NewUser(input.Name, input.Email)\n    if err != nil {\n        return nil, err // Domain validation error\n    }\n    \n    // 4. PERSIST: Save via repository\n    if err := uc.userRepo.Save(ctx, user); err != nil {\n        return nil, fmt.Errorf(\"saving user: %w\", err)\n    }\n    \n    // 5. SIDE EFFECT: Send welcome email (don't fail if this fails)\n    if err := uc.emailSender.SendWelcomeEmail(ctx, user.Email, user.Name); err != nil {\n        uc.logger.Warn(\"failed to send welcome email\", \n            \"error\", err, \n            \"userID\", user.ID,\n        )\n        // Continue - email failure shouldn't fail user creation\n    }\n    \n    // 6. LOG: Operation completed\n    uc.logger.Info(\"user created\", \"userID\", user.ID)\n    \n    return user, nil\n}\n```\n\n## Use Case Patterns\n\n### Pattern 1: Query Use Case\n\n```go\nfunc (uc *UserUseCase) GetUser(\n    ctx context.Context,\n    id string,\n) (*entities.User, error) {\n    user, err := uc.userRepo.FindByID(ctx, id)\n    if err != nil {\n        return nil, err\n    }\n    return user, nil\n}\n```\n\n### Pattern 2: Command Use Case with Transaction\n\n```go\nfunc (uc *OrderUseCase) PlaceOrder(\n    ctx context.Context,\n    input ports.PlaceOrderInput,\n) (*entities.Order, error) {\n    // Start transaction\n    tx, err := uc.txManager.Begin(ctx)\n    if err != nil {\n        return nil, err\n    }\n    defer tx.Rollback() // Rollback if not committed\n    \n    // Create order\n    order, err := entities.NewOrder(input.CustomerID, input.Items)\n    if err != nil {\n        return nil, err\n    }\n    \n    // Reserve inventory\n    for _, item := range order.Items {\n        if err := uc.inventoryRepo.Reserve(ctx, tx, item.ProductID, item.Quantity); err != nil {\n            return nil, fmt.Errorf(\"reserving inventory: %w\", err)\n        }\n    }\n    \n    // Process payment\n    payment, err := uc.paymentProcessor.Charge(ctx, order.Total, input.PaymentMethod)\n    if err != nil {\n        return nil, fmt.Errorf(\"processing payment: %w\", err)\n    }\n    order.PaymentID = payment.ID\n    \n    // Save order\n    if err := uc.orderRepo.Save(ctx, tx, order); err != nil {\n        // Refund payment if save fails\n        uc.paymentProcessor.Refund(ctx, payment.ID, order.Total)\n        return nil, fmt.Errorf(\"saving order: %w\", err)\n    }\n    \n    // Commit transaction\n    if err := tx.Commit(); err != nil {\n        return nil, err\n    }\n    \n    return order, nil\n}\n```\n\n## Use Case Guidelines\n\n| Do | Don't |\n|-----|-------|\n| Orchestrate domain objects | Implement business rules (that's the domain's job) |\n| Handle cross-cutting concerns (logging, transactions) | Know about HTTP, SQL, etc. |\n| Coordinate multiple repositories | Contain presentation logic |\n| Translate between port inputs and domain | Return infrastructure-specific errors |"
        },
        {
          "title": "Project Structure: Organizing Your Code",
          "order": 7,
          "content": "# Project Structure: Organizing Your Code\n\nA clear project structure makes hexagonal architecture visible and maintainable.\n\n## The Recommended Layout\n\n```\nmyapp/\n├── cmd/                          # Application entry points\n│   ├── api/\n│   │   └── main.go               # HTTP API server\n│   ├── cli/\n│   │   └── main.go               # CLI application\n│   └── worker/\n│       └── main.go               # Background worker\n│\n├── domain/                       # THE CORE (no external dependencies)\n│   ├── entities/\n│   │   ├── user.go               # User entity + business rules\n│   │   ├── order.go              # Order entity + business rules\n│   │   ├── money.go              # Money value object\n│   │   └── errors.go             # Domain-specific errors\n│   ├── services/\n│   │   ├── auth_service.go       # Authentication logic\n│   │   └── pricing_service.go    # Pricing calculations\n│   └── repositories/             # DRIVEN PORTS (interfaces)\n│       ├── user_repository.go\n│       ├── order_repository.go\n│       └── email_sender.go\n│\n├── application/                  # APPLICATION LAYER\n│   ├── ports/                    # DRIVING PORTS (interfaces)\n│   │   ├── user_service.go\n│   │   ├── order_service.go\n│   │   └── dto.go                # Input/Output DTOs\n│   └── usecases/                 # Use case implementations\n│       ├── user_usecase.go\n│       ├── order_usecase.go\n│       └── auth_usecase.go\n│\n├── adapters/                     # ADAPTERS (implementations)\n│   ├── http/                     # Driving: HTTP adapters\n│   │   ├── router.go\n│   │   ├── user_handler.go\n│   │   ├── order_handler.go\n│   │   ├── middleware/\n│   │   │   ├── auth.go\n│   │   │   └── logging.go\n│   │   └── dto.go                # HTTP-specific DTOs\n│   ├── graphql/                  # Driving: GraphQL adapters\n│   │   ├── resolver.go\n│   │   └── schema.graphqls\n│   ├── grpc/                     # Driving: gRPC adapters\n│   │   └── server.go\n│   ├── db/                       # Driven: Database adapters\n│   │   ├── postgres/\n│   │   │   ├── user_repository.go\n│   │   │   └── order_repository.go\n│   │   └── sqlite/\n│   │       └── user_repository.go\n│   ├── email/                    # Driven: Email adapters\n│   │   ├── sendgrid.go\n│   │   └── ses.go\n│   └── payment/                  # Driven: Payment adapters\n│       ├── stripe.go\n│       └── paypal.go\n│\n├── config/                       # Configuration\n│   └── config.go\n│\n├── pkg/                          # Shared utilities\n│   ├── logger/\n│   └── validator/\n│\n├── migrations/                   # Database migrations\n│   └── 001_create_users.sql\n│\n├── go.mod\n└── go.sum\n```\n\n## Dependency Rules Visualized\n\n```\n┌────────────────────────────────────────────────────────────────┐\n│                         cmd/ (main)                            │\n│  - Wires everything together                                   │\n│  - Creates adapters, injects into use cases                    │\n│  - Starts servers                                              │\n└───────────────────────────────┬────────────────────────────────┘\n                                │ imports\n                                ▼\n┌────────────────────────────────────────────────────────────────┐\n│                          adapters/                             │\n│  - HTTP handlers, GraphQL resolvers                            │\n│  - Database repositories                                       │\n│  - External service clients                                    │\n└───────────────────────────────┬────────────────────────────────┘\n                                │ imports\n                                ▼\n┌────────────────────────────────────────────────────────────────┐\n│                         application/                           │\n│  - Driving port interfaces                                     │\n│  - Use case implementations                                    │\n└───────────────────────────────┬────────────────────────────────┘\n                                │ imports\n                                ▼\n┌────────────────────────────────────────────────────────────────┐\n│                           domain/                              │\n│  - Entities, value objects                                     │\n│  - Domain services                                             │\n│  - Driven port interfaces (repositories)                       │\n│  - IMPORTS NOTHING FROM OTHER LAYERS                           │\n└────────────────────────────────────────────────────────────────┘\n```\n\n## Import Rules (Enforced)\n\n```go\n// ✅ domain/ can only import:\nimport (\n    \"errors\"              // stdlib\n    \"time\"                // stdlib\n    \"github.com/google/uuid\" // simple libraries\n)\n\n// ❌ domain/ cannot import:\nimport (\n    \"myapp/adapters/...\"     // NO!\n    \"myapp/application/...\"  // NO!\n    \"database/sql\"           // NO infrastructure!\n    \"net/http\"               // NO protocols!\n)\n\n// ✅ application/ can import:\nimport (\n    \"myapp/domain/entities\"\n    \"myapp/domain/repositories\"\n    \"myapp/domain/services\"\n)\n\n// ✅ adapters/ can import:\nimport (\n    \"myapp/domain/entities\"\n    \"myapp/domain/repositories\"\n    \"myapp/application/ports\"\n    \"myapp/application/usecases\"\n)\n```"
        },
        {
          "title": "Dependency Injection: Wiring It All Together",
          "order": 8,
          "content": "# Dependency Injection: Wiring It All Together\n\nDependency Injection (DI) is how we connect all the pieces without creating tight coupling.\n\n## The Problem Without DI\n\n```go\n// ❌ Tightly coupled - use case creates its own dependencies\ntype UserUseCase struct {\n    repo *postgres.UserRepository  // Concrete type!\n}\n\nfunc NewUserUseCase() *UserUseCase {\n    db, _ := sql.Open(\"postgres\", \"...\")  // Hard-coded!\n    return &UserUseCase{\n        repo: postgres.NewUserRepository(db),\n    }\n}\n\n// Problems:\n// 1. Can't test without real database\n// 2. Can't switch to different database\n// 3. Use case knows about PostgreSQL\n```\n\n## The Solution: Constructor Injection\n\n```go\n// ✅ Loosely coupled - dependencies injected via constructor\ntype UserUseCase struct {\n    repo repositories.UserRepository  // Interface!\n}\n\nfunc NewUserUseCase(repo repositories.UserRepository) *UserUseCase {\n    return &UserUseCase{repo: repo}\n}\n\n// Benefits:\n// 1. Easy to test with mock\n// 2. Easy to swap implementations\n// 3. Use case doesn't know about concrete types\n```\n\n## Complete Wiring Example\n\n```go\n// cmd/api/main.go\npackage main\n\nimport (\n    \"log/slog\"\n    \"net/http\"\n    \"os\"\n    \n    \"myapp/adapters/db/postgres\"\n    \"myapp/adapters/email/sendgrid\"\n    httpAdapter \"myapp/adapters/http\"\n    \"myapp/application/usecases\"\n    \"myapp/config\"\n    \"myapp/domain/services\"\n)\n\nfunc main() {\n    // 1. CONFIGURATION\n    cfg := config.Load()\n    \n    // 2. LOGGER\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    \n    // 3. INFRASTRUCTURE (Driven Adapters)\n    // Database\n    db, err := postgres.NewConnection(cfg.DatabaseURL)\n    if err != nil {\n        logger.Error(\"failed to connect to database\", \"error\", err)\n        os.Exit(1)\n    }\n    defer db.Close()\n    \n    // Repositories (driven adapters)\n    userRepo := postgres.NewUserRepository(db)\n    orderRepo := postgres.NewOrderRepository(db)\n    \n    // External services (driven adapters)\n    emailSender := sendgrid.NewEmailSender(cfg.SendGridAPIKey)\n    \n    // 4. DOMAIN SERVICES\n    authService := services.NewAuthService(cfg.JWTSecret)\n    pricingService := services.NewPricingService(cfg.TaxRate)\n    \n    // 5. USE CASES (Application Layer)\n    userUseCase := usecases.NewUserUseCase(\n        userRepo,\n        emailSender,\n        authService,\n        logger,\n    )\n    \n    orderUseCase := usecases.NewOrderUseCase(\n        orderRepo,\n        userRepo,\n        pricingService,\n        logger,\n    )\n    \n    // 6. HTTP HANDLERS (Driving Adapters)\n    userHandler := httpAdapter.NewUserHandler(userUseCase)\n    orderHandler := httpAdapter.NewOrderHandler(orderUseCase)\n    authMiddleware := httpAdapter.NewAuthMiddleware(authService)\n    \n    // 7. ROUTER\n    router := httpAdapter.NewRouter(\n        userHandler,\n        orderHandler,\n        authMiddleware,\n        logger,\n    )\n    \n    // 8. START SERVER\n    server := &http.Server{\n        Addr:    \":\" + cfg.Port,\n        Handler: router,\n    }\n    \n    logger.Info(\"starting server\", \"port\", cfg.Port)\n    if err := server.ListenAndServe(); err != nil {\n        logger.Error(\"server failed\", \"error\", err)\n        os.Exit(1)\n    }\n}\n```\n\n## Testing with Injected Dependencies\n\n```go\n// usecases/user_usecase_test.go\npackage usecases_test\n\ntype mockUserRepo struct {\n    users map[string]*entities.User\n}\n\nfunc (m *mockUserRepo) Save(ctx context.Context, user *entities.User) error {\n    m.users[user.ID] = user\n    return nil\n}\n\nfunc (m *mockUserRepo) FindByEmail(ctx context.Context, email string) (*entities.User, error) {\n    for _, u := range m.users {\n        if u.Email == email {\n            return u, nil\n        }\n    }\n    return nil, entities.ErrUserNotFound\n}\n\ntype mockEmailSender struct {\n    sentEmails []string\n}\n\nfunc (m *mockEmailSender) SendWelcomeEmail(ctx context.Context, to, name string) error {\n    m.sentEmails = append(m.sentEmails, to)\n    return nil\n}\n\nfunc TestCreateUser(t *testing.T) {\n    // Arrange: Create mocks\n    repo := &mockUserRepo{users: make(map[string]*entities.User)}\n    emailer := &mockEmailSender{}\n    auth := services.NewAuthService(\"test-secret\")\n    logger := slog.New(slog.NewTextHandler(io.Discard, nil))\n    \n    useCase := usecases.NewUserUseCase(repo, emailer, auth, logger)\n    \n    // Act\n    user, err := useCase.CreateUser(context.Background(), ports.CreateUserInput{\n        Name:  \"John Doe\",\n        Email: \"john@example.com\",\n    })\n    \n    // Assert\n    require.NoError(t, err)\n    assert.Equal(t, \"John Doe\", user.Name)\n    assert.Len(t, repo.users, 1)\n    assert.Contains(t, emailer.sentEmails, \"john@example.com\")\n}\n```"
        },
        {
          "title": "Testing Strategies: From Unit to E2E",
          "order": 9,
          "content": "# Testing Strategies: From Unit to E2E\n\nHexagonal architecture makes testing easier at every level.\n\n## The Testing Pyramid\n\n```\n                    /\\\n                   /  \\        E2E Tests\n                  /    \\       (Few, Slow, High Confidence)\n                 /──────\\\n                /        \\     Integration Tests\n               /          \\    (Some, Medium Speed)\n              /────────────\\\n             /              \\  Unit Tests\n            /                \\ (Many, Fast, Focused)\n           /──────────────────\\\n```\n\n## Level 1: Domain Unit Tests\n\n**What:** Test business logic in isolation\n**Speed:** Milliseconds\n**Dependencies:** None\n\n```go\n// domain/entities/user_test.go\npackage entities_test\n\nimport (\n    \"testing\"\n    \n    \"myapp/domain/entities\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/require\"\n)\n\nfunc TestNewUser_ValidInput(t *testing.T) {\n    user, err := entities.NewUser(\"John Doe\", \"john@example.com\")\n    \n    require.NoError(t, err)\n    assert.Equal(t, \"John Doe\", user.Name)\n    assert.Equal(t, \"john@example.com\", user.Email)\n    assert.NotEmpty(t, user.ID)\n}\n\nfunc TestNewUser_InvalidEmail(t *testing.T) {\n    _, err := entities.NewUser(\"John Doe\", \"not-an-email\")\n    \n    assert.ErrorIs(t, err, entities.ErrInvalidEmail)\n}\n\nfunc TestNewUser_ShortName(t *testing.T) {\n    _, err := entities.NewUser(\"J\", \"john@example.com\")\n    \n    assert.ErrorIs(t, err, entities.ErrNameTooShort)\n}\n\nfunc TestUser_UpdateEmail(t *testing.T) {\n    user, _ := entities.NewUser(\"John\", \"old@example.com\")\n    originalUpdatedAt := user.UpdatedAt\n    \n    err := user.UpdateEmail(\"new@example.com\")\n    \n    require.NoError(t, err)\n    assert.Equal(t, \"new@example.com\", user.Email)\n    assert.True(t, user.UpdatedAt.After(originalUpdatedAt))\n}\n```\n\n## Level 2: Use Case Tests with Mocks\n\n**What:** Test application logic with fake dependencies\n**Speed:** Milliseconds\n**Dependencies:** Mock implementations\n\n```go\n// application/usecases/user_usecase_test.go\npackage usecases_test\n\nfunc TestCreateUser_Success(t *testing.T) {\n    // Arrange\n    repo := mocks.NewMockUserRepository()\n    emailer := mocks.NewMockEmailSender()\n    logger := testLogger()\n    \n    uc := usecases.NewUserUseCase(repo, emailer, logger)\n    \n    // Act\n    user, err := uc.CreateUser(context.Background(), ports.CreateUserInput{\n        Name:  \"Alice\",\n        Email: \"alice@example.com\",\n    })\n    \n    // Assert\n    require.NoError(t, err)\n    assert.Equal(t, \"Alice\", user.Name)\n    \n    // Verify repository was called\n    savedUser := repo.FindSaved(user.ID)\n    require.NotNil(t, savedUser)\n    \n    // Verify email was sent\n    assert.True(t, emailer.WelcomeEmailSentTo(\"alice@example.com\"))\n}\n\nfunc TestCreateUser_DuplicateEmail(t *testing.T) {\n    // Arrange\n    repo := mocks.NewMockUserRepository()\n    repo.AddExisting(&entities.User{Email: \"taken@example.com\"})\n    \n    uc := usecases.NewUserUseCase(repo, mocks.NewMockEmailSender(), testLogger())\n    \n    // Act\n    _, err := uc.CreateUser(context.Background(), ports.CreateUserInput{\n        Name:  \"Alice\",\n        Email: \"taken@example.com\",\n    })\n    \n    // Assert\n    assert.ErrorIs(t, err, entities.ErrEmailTaken)\n}\n```\n\n## Level 3: Adapter Integration Tests\n\n**What:** Test adapters against real infrastructure\n**Speed:** Seconds\n**Dependencies:** Real database, real APIs (or sandboxes)\n\n```go\n// adapters/db/postgres/user_repository_test.go\npackage postgres_test\n\nfunc TestUserRepository_Integration(t *testing.T) {\n    if testing.Short() {\n        t.Skip(\"skipping integration test\")\n    }\n    \n    // Setup: Real database\n    db := setupTestDB(t)\n    defer db.Close()\n    \n    repo := postgres.NewUserRepository(db)\n    \n    t.Run(\"save and find\", func(t *testing.T) {\n        user, _ := entities.NewUser(\"Test User\", \"test@example.com\")\n        \n        err := repo.Save(context.Background(), user)\n        require.NoError(t, err)\n        \n        found, err := repo.FindByID(context.Background(), user.ID)\n        require.NoError(t, err)\n        assert.Equal(t, user.Name, found.Name)\n        assert.Equal(t, user.Email, found.Email)\n    })\n    \n    t.Run(\"find by email\", func(t *testing.T) {\n        user, _ := entities.NewUser(\"Email Test\", \"unique@example.com\")\n        repo.Save(context.Background(), user)\n        \n        found, err := repo.FindByEmail(context.Background(), \"unique@example.com\")\n        require.NoError(t, err)\n        assert.Equal(t, user.ID, found.ID)\n    })\n    \n    t.Run(\"not found\", func(t *testing.T) {\n        _, err := repo.FindByID(context.Background(), \"nonexistent\")\n        assert.ErrorIs(t, err, entities.ErrUserNotFound)\n    })\n}\n```\n\n## Level 4: E2E Tests\n\n**What:** Test the entire application\n**Speed:** Seconds to minutes\n**Dependencies:** Everything running\n\n```go\n// e2e/user_test.go\npackage e2e_test\n\nfunc TestUserRegistrationFlow(t *testing.T) {\n    // Start the full application\n    app := startTestApp(t)\n    defer app.Shutdown()\n    \n    // Test: Register a new user\n    resp, err := http.Post(\n        app.URL+\"/api/users\",\n        \"application/json\",\n        strings.NewReader(`{\"name\":\"E2E User\",\"email\":\"e2e@example.com\"}`),\n    )\n    require.NoError(t, err)\n    assert.Equal(t, http.StatusCreated, resp.StatusCode)\n    \n    var user UserResponse\n    json.NewDecoder(resp.Body).Decode(&user)\n    assert.Equal(t, \"E2E User\", user.Name)\n    \n    // Test: Login with the user\n    // Test: Access protected resource\n    // etc.\n}\n```"
        },
        {
          "title": "Common Mistakes and How to Avoid Them",
          "order": 10,
          "content": "# Common Mistakes and How to Avoid Them\n\nLet's learn from others' mistakes so you don't have to make them yourself!\n\n## Mistake 1: Domain Depends on Infrastructure\n\n### The Problem\n```go\n// ❌ BAD: Domain entity knows about SQL\npackage entities\n\nimport \"database/sql\"\n\ntype User struct {\n    ID   string\n    Name string\n    DB   *sql.DB  // NO! Domain shouldn't know about databases\n}\n\nfunc (u *User) Save() error {\n    _, err := u.DB.Exec(\"INSERT INTO users...\")\n    return err\n}\n```\n\n### The Fix\n```go\n// ✅ GOOD: Domain entity is pure\npackage entities\n\ntype User struct {\n    ID   string\n    Name string\n}\n\n// Persistence is handled by repository adapter, not the entity\n```\n\n## Mistake 2: Anemic Domain Model\n\n### The Problem\n```go\n// ❌ BAD: Entity is just a data container\ntype User struct {\n    ID        string\n    Name      string\n    Email     string\n    CreatedAt time.Time\n}\n\n// All logic in use case\nfunc (uc *UserUseCase) UpdateUserEmail(id, newEmail string) error {\n    user, _ := uc.repo.FindByID(id)\n    \n    // Validation logic in use case - should be in entity!\n    if !isValidEmail(newEmail) {\n        return errors.New(\"invalid email\")\n    }\n    \n    user.Email = newEmail\n    user.UpdatedAt = time.Now()\n    return uc.repo.Save(user)\n}\n```\n\n### The Fix\n```go\n// ✅ GOOD: Entity has behavior\ntype User struct {\n    ID        string\n    name      string  // Private!\n    email     string  // Private!\n    updatedAt time.Time\n}\n\nfunc (u *User) UpdateEmail(newEmail string) error {\n    if !isValidEmail(newEmail) {\n        return ErrInvalidEmail\n    }\n    u.email = newEmail\n    u.updatedAt = time.Now()\n    return nil\n}\n\n// Use case is simpler\nfunc (uc *UserUseCase) UpdateUserEmail(id, newEmail string) error {\n    user, _ := uc.repo.FindByID(id)\n    if err := user.UpdateEmail(newEmail); err != nil {\n        return err\n    }\n    return uc.repo.Save(user)\n}\n```\n\n## Mistake 3: God Use Case\n\n### The Problem\n```go\n// ❌ BAD: Use case does too much\ntype ApplicationUseCase struct {\n    userRepo    repositories.UserRepository\n    orderRepo   repositories.OrderRepository\n    productRepo repositories.ProductRepository\n    paymentGw   repositories.PaymentGateway\n    emailSender repositories.EmailSender\n    smsService  repositories.SMSService\n    // ... 10 more dependencies\n}\n\nfunc (uc *ApplicationUseCase) DoEverything(...) { ... }\n```\n\n### The Fix\n```go\n// ✅ GOOD: Focused use cases\ntype UserUseCase struct {\n    userRepo    repositories.UserRepository\n    emailSender repositories.EmailSender\n}\n\ntype OrderUseCase struct {\n    orderRepo   repositories.OrderRepository\n    paymentGw   repositories.PaymentGateway\n}\n```\n\n## Mistake 4: Leaky Abstractions in Ports\n\n### The Problem\n```go\n// ❌ BAD: Port leaks HTTP concepts\ntype UserService interface {\n    HandleHTTPRequest(w http.ResponseWriter, r *http.Request)\n}\n\n// ❌ BAD: Port leaks SQL concepts  \ntype UserRepository interface {\n    Query(sql string) (*sql.Rows, error)\n}\n```\n\n### The Fix\n```go\n// ✅ GOOD: Ports use domain concepts only\ntype UserService interface {\n    CreateUser(ctx context.Context, input CreateUserInput) (*User, error)\n}\n\ntype UserRepository interface {\n    Save(ctx context.Context, user *User) error\n    FindByID(ctx context.Context, id string) (*User, error)\n}\n```\n\n## Mistake 5: Over-Engineering Simple Apps\n\n### The Problem\n```go\n// ❌ OVERKILL for a simple CRUD app:\n// - 15 layers\n// - 50 interfaces\n// - 100 files\n// For something that could be 3 files\n```\n\n### The Fix\n\n**Start simple, refactor when needed:**\n\n```go\n// ✅ For a simple app, start with:\n// - handlers.go (HTTP)\n// - service.go (business logic)\n// - repository.go (database)\n\n// As complexity grows, extract:\n// - Entities when you have real business rules\n// - Ports when you need multiple implementations\n// - Use cases when orchestration gets complex\n```\n\n## Mistake 6: Testing the Wrong Things\n\n### The Problem\n```go\n// ❌ BAD: Testing adapter logic with domain tests\nfunc TestUserRepository(t *testing.T) {\n    user := &User{Name: \"Test\"}\n    // This tests SQL, not domain logic!\n}\n```\n\n### The Fix\n```go\n// ✅ GOOD: Test each layer appropriately\n// Domain tests: pure business logic\nfunc TestNewUser_Validation(t *testing.T) { ... }\n\n// Use case tests: orchestration with mocks\nfunc TestCreateUser_Flow(t *testing.T) { ... }\n\n// Integration tests: adapters with real infrastructure\nfunc TestUserRepository_PostgreSQL(t *testing.T) { ... }\n```\n\n## Quick Reference: Do's and Don'ts\n\n| Layer | Do | Don't |\n|-------|-----|-------|\n| Domain | Business rules, validation | Import infrastructure |\n| Ports | Define interfaces | Know implementations |\n| Adapters | Translate, connect | Contain business logic |\n| Use Cases | Orchestrate | Make business decisions |"
        },
        {
          "title": "Evolution: When and How to Adopt Hexagonal",
          "order": 11,
          "content": "# Evolution: When and How to Adopt Hexagonal\n\nNot every project needs full hexagonal architecture from day one. Let's discuss when and how to adopt it.\n\n## When to Use Hexagonal Architecture\n\n### Good Fit ✅\n- **Complex business logic** that needs protection\n- **Multiple interfaces** (REST + GraphQL + CLI)\n- **Changing infrastructure** requirements\n- **Long-lived projects** (years, not weeks)\n- **Large teams** needing clear boundaries\n- **High test coverage** requirements\n\n### Maybe Overkill 🤔\n- Simple CRUD applications\n- Short-lived prototypes\n- Single-developer projects\n- Apps with trivial business logic\n\n## The Evolution Path\n\n### Stage 1: Simple Start\n```\n┌─────────────┐\n│   main.go   │  Everything in one file\n└─────────────┘  - Handlers\n                 - Business logic\n                 - Database calls\n```\n\n### Stage 2: Basic Separation\n```\n┌─────────────┐  ┌─────────────┐  ┌─────────────┐\n│  handlers   │──│   service   │──│    repo     │\n└─────────────┘  └─────────────┘  └─────────────┘\n```\n\n### Stage 3: Extract Interfaces\n```\n┌─────────────┐      ┌──────────────┐      ┌─────────────┐\n│  handlers   │      │   service    │      │    repo     │\n│  (adapter)  │──▶   │  implements  │  ◀──│  (adapter)  │\n└─────────────┘   interface      interface └─────────────┘\n```\n\n### Stage 4: Full Hexagonal\n```\n     Adapters        Application         Domain\n┌──────────────┐   ┌─────────────┐   ┌─────────────┐\n│ HTTP Handler │──▶│  Use Case   │──▶│  Entities   │\n│ CLI Handler  │   │             │   │  Services   │\n│ GraphQL      │   └──────┬──────┘   └─────────────┘\n└──────────────┘          │\n                    ┌─────▼─────┐\n┌──────────────┐    │   Ports   │\n│ PostgreSQL   │◀──│(Interfaces)│\n│ Redis Cache  │    └───────────┘\n│ SendGrid     │\n└──────────────┘\n```\n\n## Refactoring to Hexagonal: Step by Step\n\n### Step 1: Identify Your Domain\n\nAsk: \"What does this application DO?\"\n\n```go\n// Before: Mixed concerns\nfunc handleCreateOrder(w http.ResponseWriter, r *http.Request) {\n    // HTTP parsing\n    // Validation\n    // Business logic\n    // Database calls\n    // Email sending\n    // HTTP response\n}\n\n// After: Identified domain\n// Domain: \"Create an order with items, calculate total, validate stock\"\n```\n\n### Step 2: Extract Entities\n\n```go\n// Create domain/entities/order.go\npackage entities\n\ntype Order struct {\n    ID        string\n    Items     []OrderItem\n    Total     Money\n    Status    OrderStatus\n    CreatedAt time.Time\n}\n\nfunc NewOrder(items []OrderItem) (*Order, error) {\n    if len(items) == 0 {\n        return nil, ErrEmptyOrder\n    }\n    \n    order := &Order{\n        ID:        uuid.New().String(),\n        Items:     items,\n        Status:    StatusPending,\n        CreatedAt: time.Now(),\n    }\n    order.calculateTotal()\n    return order, nil\n}\n```\n\n### Step 3: Define Driven Ports\n\n```go\n// Create domain/repositories/order_repository.go\npackage repositories\n\ntype OrderRepository interface {\n    Save(ctx context.Context, order *entities.Order) error\n    FindByID(ctx context.Context, id string) (*entities.Order, error)\n}\n```\n\n### Step 4: Create Adapters\n\n```go\n// Create adapters/db/postgres/order_repository.go\npackage postgres\n\ntype OrderRepository struct {\n    db *sql.DB\n}\n\nfunc (r *OrderRepository) Save(ctx context.Context, order *entities.Order) error {\n    // PostgreSQL implementation\n}\n```\n\n### Step 5: Extract Use Cases\n\n```go\n// Create application/usecases/order_usecase.go\npackage usecases\n\ntype OrderUseCase struct {\n    orderRepo repositories.OrderRepository\n}\n\nfunc (uc *OrderUseCase) CreateOrder(\n    ctx context.Context,\n    input CreateOrderInput,\n) (*entities.Order, error) {\n    order, err := entities.NewOrder(input.Items)\n    if err != nil {\n        return nil, err\n    }\n    if err := uc.orderRepo.Save(ctx, order); err != nil {\n        return nil, err\n    }\n    return order, nil\n}\n```\n\n### Step 6: Update Handlers\n\n```go\n// Update adapters/http/order_handler.go\npackage http\n\ntype OrderHandler struct {\n    orderService ports.OrderService\n}\n\nfunc (h *OrderHandler) CreateOrder(w http.ResponseWriter, r *http.Request) {\n    var req CreateOrderRequest\n    json.NewDecoder(r.Body).Decode(&req)\n    \n    order, err := h.orderService.CreateOrder(r.Context(), toInput(req))\n    // Handle response\n}\n```\n\n## Key Takeaways\n\n1. **Start simple** - Don't over-engineer from day one\n2. **Evolve gradually** - Refactor as complexity grows\n3. **Focus on the domain** - That's what matters most\n4. **Test at boundaries** - Ports make testing easy\n5. **Stay pragmatic** - Rules are guidelines, not laws"
        },
        {
          "title": "Real-World Case Study: This Course Platform",
          "order": 12,
          "content": "# Real-World Case Study: This Course Platform\n\nLet's look at how this very course platform implements hexagonal architecture!\n\n## The Project Structure\n\n```\nbackend/\n├── cmd/api/\n│   └── main.go                 # Wiring & server startup\n├── domain/\n│   ├── entities/\n│   │   ├── course.go           # Course, Lesson entities\n│   │   ├── user.go             # User entity\n│   │   └── errors.go           # Domain errors\n│   ├── services/\n│   │   └── auth_service.go     # JWT authentication\n│   └── repositories/\n│       ├── course_repository.go # LibraryCourseRepository interface\n│       └── user_repository.go   # UserRepository interface\n├── application/\n│   ├── ports/\n│   │   └── auth_port.go        # AuthService interface\n│   └── usecases/\n│       ├── auth_usecase.go     # Login, Register\n│       └── user_usecase.go     # User management\n└── adapters/\n    ├── graphql/\n    │   ├── resolver.go         # GraphQL driving adapter\n    │   └── schema.graphqls     # GraphQL schema\n    ├── http/\n    │   ├── auth_middleware.go  # JWT middleware\n    │   └── attachment_handler.go # File uploads\n    └── db/\n        ├── sqlite.go           # Database connection\n        ├── course_repository.go # SQLite implementation\n        └── user_repository.go   # SQLite implementation\n```\n\n## The Domain: Course Entity\n\n```go\n// domain/entities/course.go\npackage entities\n\ntype LibraryCourse struct {\n    ID             string\n    Title          string\n    Description    string\n    Lessons        []Lesson\n    Author         string\n    AuthorID       string\n    Tags           []string\n    Difficulty     Difficulty\n    EstimatedHours int\n    CreatedAt      time.Time\n    UpdatedAt      time.Time\n}\n\nfunc NewLibraryCourse(title, description, author, authorID string) (*LibraryCourse, error) {\n    // Business rule: title is required\n    if title == \"\" {\n        return nil, ErrTitleRequired\n    }\n    \n    // Business rule: author is required\n    if author == \"\" {\n        return nil, ErrAuthorRequired\n    }\n    \n    now := time.Now()\n    return &LibraryCourse{\n        ID:          uuid.New().String(),\n        Title:       title,\n        Description: description,\n        Author:      author,\n        AuthorID:    authorID,\n        Difficulty:  Beginner,\n        CreatedAt:   now,\n        UpdatedAt:   now,\n    }, nil\n}\n\n// Business logic: Add a lesson to the course\nfunc (c *LibraryCourse) AddLesson(lesson Lesson) {\n    lesson.Order = len(c.Lessons) + 1\n    c.Lessons = append(c.Lessons, lesson)\n    c.UpdatedAt = time.Now()\n}\n\n// Business logic: Reorder lessons\nfunc (c *LibraryCourse) ReorderLessons(newOrder []int) error {\n    if len(newOrder) != len(c.Lessons) {\n        return ErrInvalidLessonOrder\n    }\n    // Reordering logic...\n    c.UpdatedAt = time.Now()\n    return nil\n}\n```\n\n## The Driven Port: Repository Interface\n\n```go\n// domain/repositories/course_repository.go\npackage repositories\n\ntype LibraryCourseRepository interface {\n    Create(ctx context.Context, course *entities.LibraryCourse) (*entities.LibraryCourse, error)\n    GetByID(ctx context.Context, id string) (*entities.LibraryCourse, error)\n    Update(ctx context.Context, course *entities.LibraryCourse) (*entities.LibraryCourse, error)\n    Delete(ctx context.Context, id string) error\n    List(ctx context.Context, filter CourseFilter) ([]*entities.LibraryCourse, error)\n    GetByAuthorID(ctx context.Context, authorID string) ([]*entities.LibraryCourse, error)\n    GetByTag(ctx context.Context, tag string) ([]*entities.LibraryCourse, error)\n}\n```\n\n## The Driven Adapter: SQLite Implementation\n\n```go\n// adapters/db/course_repository.go\npackage db\n\ntype LibraryCourseRepository struct {\n    db *SQLiteDB\n}\n\nfunc (r *LibraryCourseRepository) Create(\n    ctx context.Context,\n    course *entities.LibraryCourse,\n) (*entities.LibraryCourse, error) {\n    // Translate: domain entity → SQL\n    lessonsJSON, _ := json.Marshal(course.Lessons)\n    tagsJSON, _ := json.Marshal(course.Tags)\n    \n    query := `INSERT INTO library_courses \n              (id, title, description, lessons, author, author_id, tags, ...)\n              VALUES (?, ?, ?, ?, ?, ?, ?, ...)`\n    \n    _, err := r.db.ExecContext(ctx, query,\n        course.ID,\n        course.Title,\n        course.Description,\n        string(lessonsJSON),\n        course.Author,\n        course.AuthorID,\n        string(tagsJSON),\n        // ...\n    )\n    \n    return course, err\n}\n```\n\n## The Driving Adapter: GraphQL Resolver\n\n```go\n// adapters/graphql/schema.resolvers.go\npackage graphql\n\nfunc (r *mutationResolver) CreateLibraryCourse(\n    ctx context.Context,\n    input model.CreateLibraryCourseInput,\n) (*model.LibraryCourse, error) {\n    // 1. Get user from context (authentication)\n    userID := auth.GetUserIDFromContext(ctx)\n    if userID == \"\" {\n        return nil, fmt.Errorf(\"authentication required\")\n    }\n    \n    // 2. Create domain entity\n    course, err := entities.NewLibraryCourse(\n        input.Title,\n        input.Description,\n        input.Author,\n        userID,\n    )\n    if err != nil {\n        return nil, err // Domain validation error\n    }\n    \n    // 3. Add lessons\n    for _, l := range input.Lessons {\n        course.AddLesson(entities.Lesson{\n            Title:   l.Title,\n            Content: l.Content,\n            Order:   l.Order,\n        })\n    }\n    \n    // 4. Persist via repository\n    created, err := r.LibraryCourseRepo.Create(ctx, course)\n    if err != nil {\n        return nil, err\n    }\n    \n    // 5. Translate to GraphQL model\n    return toGraphQLCourse(created), nil\n}\n```\n\n## The Wiring: main.go\n\n```go\n// cmd/api/main.go\nfunc main() {\n    cfg := config.Load()\n    \n    // Infrastructure\n    database, _ := db.NewSQLiteDB(cfg.DatabasePath)\n    database.Migrate()\n    \n    // Repositories (driven adapters)\n    userRepo := db.NewUserRepository(database)\n    courseRepo := db.NewLibraryCourseRepository(database)\n    \n    // Domain services\n    authService := services.NewAuthService(cfg.JWTSecret)\n    \n    // Use cases\n    authUseCase := usecases.NewAuthUseCase(userRepo, authService)\n    \n    // GraphQL resolver (driving adapter)\n    resolver := &graphql.Resolver{\n        UserRepo:          userRepo,\n        LibraryCourseRepo: courseRepo,\n        AuthUseCase:       authUseCase,\n    }\n    \n    // Server\n    srv := handler.NewDefaultServer(graphql.NewExecutableSchema(...))\n    \n    r := chi.NewRouter()\n    r.Use(httpAdapter.AuthMiddleware(authService))\n    r.Handle(\"/graphql\", srv)\n    \n    http.ListenAndServe(\":8082\", r)\n}\n```\n\n## Why This Architecture Works\n\n1. **Easy to test**: We can test course creation without a database\n2. **Easy to extend**: Adding REST API? Just new adapters\n3. **Easy to change**: Switch from SQLite to PostgreSQL? Just new adapter\n4. **Clear boundaries**: Everyone knows where code belongs\n\n## Congratulations!\n\nYou've completed the Hexagonal Architecture course. You now understand:\n\n- ✅ The problem hexagonal solves\n- ✅ Ports and adapters\n- ✅ Domain-driven design basics\n- ✅ Testing strategies\n- ✅ When and how to adopt it\n\n**Next steps:**\n1. Apply these concepts to your current project\n2. Start simple, evolve as needed\n3. Focus on your domain first\n\nHappy coding! 🎉"
        }
      ]
    }
  }
}
