package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations will be copied through when generating and any unknown code
// will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"

	"github.com/project/backend/application/ports"
	"github.com/project/backend/domain/entities"
)

// CreateUser creates a new user
func (r *mutationResolver) CreateUser(ctx context.Context, input CreateUserInput) (*entities.User, error) {
	return r.UserUseCase.CreateUser(ctx, ports.CreateUserInput{
		Email:    input.Email,
		Name:     input.Name,
		Password: input.Password,
	})
}

// UpdateUser updates an existing user
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input UpdateUserInput) (*entities.User, error) {
	return r.UserUseCase.UpdateUser(ctx, id, ports.UpdateUserInput{
		Name:  input.Name,
		Email: input.Email,
	})
}

// DeleteUser deletes a user
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	err := r.UserUseCase.DeleteUser(ctx, id)
	return err == nil, err
}

// User returns a single user by ID
func (r *queryResolver) User(ctx context.Context, id string) (*entities.User, error) {
	return r.UserUseCase.GetUser(ctx, id)
}

// Users returns a paginated list of users
func (r *queryResolver) Users(ctx context.Context, pagination *PaginationInput) (*UserConnection, error) {
	input := ports.PaginationInput{Page: 1, Limit: 20}
	if pagination != nil {
		if pagination.Page != nil {
			input.Page = *pagination.Page
		}
		if pagination.Limit != nil {
			input.Limit = *pagination.Limit
		}
	}

	result, err := r.UserUseCase.ListUsers(ctx, input)
	if err != nil {
		return nil, err
	}

	return &UserConnection{
		Users:   result.Users,
		Total:   result.Total,
		Page:    result.Page,
		Limit:   result.Limit,
		HasMore: result.HasMore,
	}, nil
}

// Users resolves the users field on UserConnection (required by gqlgen)
func (r *userConnectionResolver) Users(ctx context.Context, obj *UserConnection) ([]*entities.User, error) {
	return obj.Users, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// UserConnection returns UserConnectionResolver implementation.
func (r *Resolver) UserConnection() UserConnectionResolver { return &userConnectionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userConnectionResolver struct{ *Resolver }
