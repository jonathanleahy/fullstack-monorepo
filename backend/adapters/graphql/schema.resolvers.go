package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"errors"
	"fmt"
	"time"

	httpAdapter "github.com/project/backend/adapters/http"
	"github.com/project/backend/application/ports"
	"github.com/project/backend/domain/entities"
)

// DownloadURL is the resolver for the downloadUrl field.
func (r *attachmentResolver) DownloadURL(ctx context.Context, obj *entities.Attachment) (string, error) {
	return fmt.Sprintf("/api/attachments/%s", obj.ID), nil
}

// HasSublessons is the resolver for the hasSublessons field.
func (r *lessonResolver) HasSublessons(ctx context.Context, obj *entities.Lesson) (bool, error) {
	return obj.HasSublessons(), nil
}

// TotalLessonCount is the resolver for the totalLessonCount field.
func (r *libraryCourseResolver) TotalLessonCount(ctx context.Context, obj *entities.LibraryCourse) (int, error) {
	return obj.TotalLessonCount(), nil
}

// CreateUser creates a new user
func (r *mutationResolver) CreateUser(ctx context.Context, input CreateUserInput) (*entities.User, error) {
	return r.UserUseCase.CreateUser(ctx, ports.CreateUserInput{
		Email:    input.Email,
		Name:     input.Name,
		Password: input.Password,
	})
}

// UpdateUser updates an existing user
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input UpdateUserInput) (*entities.User, error) {
	return r.UserUseCase.UpdateUser(ctx, id, ports.UpdateUserInput{
		Name:  input.Name,
		Email: input.Email,
	})
}

// DeleteUser deletes a user
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	err := r.UserUseCase.DeleteUser(ctx, id)
	return err == nil, err
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input RegisterInput) (*AuthPayload, error) {
	result, err := r.AuthUseCase.Register(ctx, ports.RegisterInput{
		Email:    input.Email,
		Name:     input.Name,
		Password: input.Password,
	})
	if err != nil {
		return nil, err
	}

	return &AuthPayload{
		User:         result.User,
		AccessToken:  result.AccessToken,
		RefreshToken: result.RefreshToken,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input LoginInput) (*AuthPayload, error) {
	result, err := r.AuthUseCase.Login(ctx, ports.LoginInput{
		Email:    input.Email,
		Password: input.Password,
	})
	if err != nil {
		return nil, err
	}

	return &AuthPayload{
		User:         result.User,
		AccessToken:  result.AccessToken,
		RefreshToken: result.RefreshToken,
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*TokenPayload, error) {
	result, err := r.AuthUseCase.RefreshToken(ctx, refreshToken)
	if err != nil {
		return nil, err
	}

	return &TokenPayload{
		AccessToken:  result.AccessToken,
		RefreshToken: result.RefreshToken,
	}, nil
}

// CreateLibraryCourse is the resolver for the createLibraryCourse field.
func (r *mutationResolver) CreateLibraryCourse(ctx context.Context, input CreateLibraryCourseInput) (*entities.LibraryCourse, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	lessons := convertLessonsInput(input.Lessons)

	tags := []string{}
	if input.Tags != nil {
		tags = input.Tags
	}

	course, err := entities.NewLibraryCourse(
		input.Title,
		input.Description,
		lessons,
		input.Author,
		userID,
		tags,
		input.Difficulty,
		input.EstimatedHours,
	)
	if err != nil {
		return nil, err
	}

	return r.LibraryCourseRepo.Create(ctx, course)
}

// UpdateLibraryCourse is the resolver for the updateLibraryCourse field.
func (r *mutationResolver) UpdateLibraryCourse(ctx context.Context, id string, input UpdateLibraryCourseInput) (*entities.LibraryCourse, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	course, err := r.LibraryCourseRepo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	// Check if user is the author
	if course.AuthorID != userID {
		return nil, errors.New("not authorized to update this course")
	}

	if input.Title != nil {
		course.Title = *input.Title
	}
	if input.Description != nil {
		course.Description = *input.Description
	}
	if input.Author != nil {
		course.Author = *input.Author
	}
	if input.Tags != nil {
		course.Tags = input.Tags
	}
	if input.Difficulty != nil {
		course.Difficulty = *input.Difficulty
	}
	if input.EstimatedHours != nil {
		course.EstimatedHours = *input.EstimatedHours
	}
	if input.Lessons != nil {
		course.Lessons = convertLessonsInput(input.Lessons)
	}

	return r.LibraryCourseRepo.Update(ctx, course)
}

// DeleteLibraryCourse is the resolver for the deleteLibraryCourse field.
func (r *mutationResolver) DeleteLibraryCourse(ctx context.Context, id string) (bool, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return false, errors.New("authentication required")
	}

	course, err := r.LibraryCourseRepo.GetByID(ctx, id)
	if err != nil {
		return false, err
	}

	// Check if user is the author
	if course.AuthorID != userID {
		return false, errors.New("not authorized to delete this course")
	}

	err = r.LibraryCourseRepo.Delete(ctx, id)
	return err == nil, err
}

// ImportCourses is the resolver for the importCourses field.
func (r *mutationResolver) ImportCourses(ctx context.Context, input ImportCoursesInput) ([]*entities.LibraryCourse, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	var importedCourses []*entities.LibraryCourse
	for _, courseInput := range input.Courses {
		lessons := convertLessonsInput(courseInput.Lessons)

		tags := []string{}
		if courseInput.Tags != nil {
			tags = courseInput.Tags
		}

		course, err := entities.NewLibraryCourse(
			courseInput.Title,
			courseInput.Description,
			lessons,
			courseInput.Author,
			userID,
			tags,
			courseInput.Difficulty,
			courseInput.EstimatedHours,
		)
		if err != nil {
			return nil, err
		}

		created, err := r.LibraryCourseRepo.Create(ctx, course)
		if err != nil {
			return nil, err
		}
		importedCourses = append(importedCourses, created)
	}

	return importedCourses, nil
}

// StartCourse is the resolver for the startCourse field.
func (r *mutationResolver) StartCourse(ctx context.Context, input StartCourseInput) (*entities.UserCourse, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	// Verify the library course exists
	_, err := r.LibraryCourseRepo.GetByID(ctx, input.LibraryCourseID)
	if err != nil {
		return nil, err
	}

	// Check if user already has this course
	existing, err := r.UserCourseRepo.GetByUserAndCourse(ctx, userID, input.LibraryCourseID)
	if err == nil && existing != nil {
		return existing, nil // Return existing enrollment
	}

	userCourse, err := entities.NewUserCourse(userID, input.LibraryCourseID)
	if err != nil {
		return nil, err
	}

	return r.UserCourseRepo.Create(ctx, userCourse)
}

// UpdateProgress is the resolver for the updateProgress field.
func (r *mutationResolver) UpdateProgress(ctx context.Context, input UpdateProgressInput) (*entities.UserCourse, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	userCourse, err := r.UserCourseRepo.GetByID(ctx, input.UserCourseID)
	if err != nil {
		return nil, err
	}

	// Verify ownership
	if userCourse.UserID != userID {
		return nil, errors.New("not authorized to update this course")
	}

	if err := userCourse.UpdateProgress(input.Progress); err != nil {
		return nil, err
	}

	if input.CurrentLessonIndex != nil {
		userCourse.CurrentLessonIndex = *input.CurrentLessonIndex
	}

	return r.UserCourseRepo.Update(ctx, userCourse)
}

// DropCourse is the resolver for the dropCourse field.
func (r *mutationResolver) DropCourse(ctx context.Context, id string) (bool, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return false, errors.New("authentication required")
	}

	userCourse, err := r.UserCourseRepo.GetByID(ctx, id)
	if err != nil {
		return false, err
	}

	// Verify ownership
	if userCourse.UserID != userID {
		return false, errors.New("not authorized to drop this course")
	}

	err = r.UserCourseRepo.Delete(ctx, id)
	return err == nil, err
}

// EnrollInCourse is the resolver for the enrollInCourse field.
func (r *mutationResolver) EnrollInCourse(ctx context.Context, libraryCourseID string) (*entities.UserCourse, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	// Verify the library course exists
	_, err := r.LibraryCourseRepo.GetByID(ctx, libraryCourseID)
	if err != nil {
		return nil, err
	}

	// Check if user already has this course
	existing, err := r.UserCourseRepo.GetByUserAndCourse(ctx, userID, libraryCourseID)
	if err == nil && existing != nil {
		return existing, nil // Return existing enrollment
	}

	userCourse, err := entities.NewUserCourse(userID, libraryCourseID)
	if err != nil {
		return nil, err
	}

	return r.UserCourseRepo.Create(ctx, userCourse)
}

// UnenrollFromCourse is the resolver for the unenrollFromCourse field.
func (r *mutationResolver) UnenrollFromCourse(ctx context.Context, libraryCourseID string) (bool, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return false, errors.New("authentication required")
	}

	userCourse, err := r.UserCourseRepo.GetByUserAndCourse(ctx, userID, libraryCourseID)
	if err != nil {
		return false, err
	}

	// Verify ownership
	if userCourse.UserID != userID {
		return false, errors.New("not authorized to unenroll from this course")
	}

	err = r.UserCourseRepo.Delete(ctx, userCourse.ID)
	return err == nil, err
}

// UpdateCourseProgress is the resolver for the updateCourseProgress field.
func (r *mutationResolver) UpdateCourseProgress(ctx context.Context, libraryCourseID string, lessonIndex int, completed bool) (*entities.UserCourse, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	// Get library course to know total lessons
	libraryCourse, err := r.LibraryCourseRepo.GetByID(ctx, libraryCourseID)
	if err != nil {
		return nil, err
	}

	userCourse, err := r.UserCourseRepo.GetByUserAndCourse(ctx, userID, libraryCourseID)
	if err != nil {
		return nil, err
	}

	// Verify ownership
	if userCourse.UserID != userID {
		return nil, errors.New("not authorized to update this course")
	}

	// Use TotalLessonCount() to include all sublessons in the count
	totalLessons := libraryCourse.TotalLessonCount()

	if completed {
		if err := userCourse.MarkLessonCompleted(lessonIndex, totalLessons); err != nil {
			return nil, err
		}
	} else {
		if err := userCourse.MarkLessonIncomplete(lessonIndex, totalLessons); err != nil {
			return nil, err
		}
	}

	return r.UserCourseRepo.Update(ctx, userCourse)
}

// SetCurrentLesson is the resolver for the setCurrentLesson field.
func (r *mutationResolver) SetCurrentLesson(ctx context.Context, libraryCourseID string, lessonIndex int) (*entities.UserCourse, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	userCourse, err := r.UserCourseRepo.GetByUserAndCourse(ctx, userID, libraryCourseID)
	if err != nil {
		return nil, err
	}

	// Verify ownership
	if userCourse.UserID != userID {
		return nil, errors.New("not authorized to update this course")
	}

	if err := userCourse.SetCurrentLesson(lessonIndex); err != nil {
		return nil, err
	}

	return r.UserCourseRepo.Update(ctx, userCourse)
}

// AddBookmark is the resolver for the addBookmark field.
func (r *mutationResolver) AddBookmark(ctx context.Context, libraryCourseID string, lessonIndex int, note *string) (*entities.Bookmark, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	noteValue := ""
	if note != nil {
		noteValue = *note
	}

	bookmark, err := entities.NewBookmark(userID, libraryCourseID, lessonIndex, noteValue)
	if err != nil {
		return nil, err
	}

	return r.BookmarkRepo.Create(ctx, bookmark)
}

// RemoveBookmark is the resolver for the removeBookmark field.
func (r *mutationResolver) RemoveBookmark(ctx context.Context, libraryCourseID string, lessonIndex int) (bool, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return false, errors.New("authentication required")
	}

	err := r.BookmarkRepo.DeleteByUserAndLesson(ctx, userID, libraryCourseID, lessonIndex)
	return err == nil, err
}

// RecordCourseView is the resolver for the recordCourseView field.
func (r *mutationResolver) RecordCourseView(ctx context.Context, libraryCourseID string) (bool, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	// userID can be empty for anonymous views

	view, err := entities.NewCourseView(libraryCourseID, userID)
	if err != nil {
		return false, err
	}

	err = r.AnalyticsRepo.RecordView(ctx, view)
	return err == nil, err
}

// DeleteAttachment is the resolver for the deleteAttachment field.
func (r *mutationResolver) DeleteAttachment(ctx context.Context, id string) (bool, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return false, errors.New("authentication required")
	}

	// Get attachment to verify ownership via course
	attachment, err := r.AttachmentRepo.GetByID(ctx, id)
	if err != nil {
		return false, err
	}

	// Get course to verify user is the author
	course, err := r.LibraryCourseRepo.GetByID(ctx, attachment.LibraryCourseID)
	if err != nil {
		return false, err
	}

	if course.AuthorID != userID {
		return false, errors.New("only the course author can delete attachments")
	}

	// Note: File deletion is handled by the REST endpoint
	// This mutation only handles database deletion for GraphQL convenience
	return r.AttachmentRepo.Delete(ctx, id) == nil, nil
}

// SubmitQuizAttempt is the resolver for the submitQuizAttempt field.
func (r *mutationResolver) SubmitQuizAttempt(ctx context.Context, input SubmitQuizAttemptInput) (*entities.QuizAttempt, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	attempt := entities.NewQuizAttempt(
		userID,
		input.CourseID,
		input.QuizType,
		input.QuizID,
		input.Score,
		input.MaxScore,
		input.TotalQuestions,
		input.CorrectCount,
	)

	savedAttempt, err := r.QuizRepo.SaveAttempt(ctx, attempt)
	if err != nil {
		return nil, err
	}

	// Save individual responses
	for _, resp := range input.Responses {
		response := &entities.QuizResponse{
			AttemptID:      savedAttempt.ID,
			QuestionID:     resp.QuestionID,
			UserAnswer:     []byte(resp.UserAnswer),
			IsCorrect:      resp.IsCorrect,
			PointsEarned:   resp.PointsEarned,
			PointsPossible: resp.PointsPossible,
		}
		if resp.Confidence != nil {
			response.Confidence = *resp.Confidence
		}
		if resp.TimeTakenSeconds != nil {
			response.TimeTakenSec = *resp.TimeTakenSeconds
		}

		if _, err := r.QuizRepo.SaveResponse(ctx, response); err != nil {
			return nil, err
		}
	}

	return savedAttempt, nil
}

// AddToReviewQueue is the resolver for the addToReviewQueue field.
func (r *mutationResolver) AddToReviewQueue(ctx context.Context, courseID string, quizID string, questionID string, concept string) (*entities.ReviewQueueItem, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	now := time.Now()
	item := &entities.ReviewQueueItem{
		UserID:      userID,
		CourseID:    courseID,
		QuizID:      quizID,
		QuestionID:  questionID,
		Concept:     concept,
		WrongCount:  1,
		LastAttempt: now,
		NextReview:  now.Add(24 * time.Hour), // Review in 24 hours
		Stability:   1.0,
	}

	if err := r.QuizRepo.AddToReviewQueue(ctx, item); err != nil {
		return nil, err
	}

	return item, nil
}

// RemoveFromReviewQueue is the resolver for the removeFromReviewQueue field.
func (r *mutationResolver) RemoveFromReviewQueue(ctx context.Context, courseID string, questionID string) (bool, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return false, errors.New("authentication required")
	}

	err := r.QuizRepo.RemoveFromReviewQueue(ctx, userID, courseID, questionID)
	return err == nil, err
}

// UpdateLessonContent is the resolver for the updateLessonContent field.
func (r *mutationResolver) UpdateLessonContent(ctx context.Context, input UpdateLessonContentInput) (bool, error) {
	// Check if folder-based repository is available
	if r.FolderCourseRepo == nil {
		return false, errors.New("content editing only available for folder-based courses")
	}

	// Convert lesson path from []int to []int
	lessonPath := make([]int, len(input.LessonPath))
	for i, v := range input.LessonPath {
		lessonPath[i] = v
	}

	err := r.FolderCourseRepo.UpdateLessonContent(ctx, input.LibraryCourseID, lessonPath, input.Content)
	if err != nil {
		return false, fmt.Errorf("failed to update lesson content: %w", err)
	}

	return true, nil
}

// User returns a single user by ID
func (r *queryResolver) User(ctx context.Context, id string) (*entities.User, error) {
	return r.UserUseCase.GetUser(ctx, id)
}

// Users returns a paginated list of users
func (r *queryResolver) Users(ctx context.Context, pagination *PaginationInput) (*UserConnection, error) {
	input := ports.PaginationInput{Page: 1, Limit: 20}
	if pagination != nil {
		if pagination.Page != nil {
			input.Page = *pagination.Page
		}
		if pagination.Limit != nil {
			input.Limit = *pagination.Limit
		}
	}

	result, err := r.UserUseCase.ListUsers(ctx, input)
	if err != nil {
		return nil, err
	}

	return &UserConnection{
		Users:   result.Users,
		Total:   result.Total,
		Page:    result.Page,
		Limit:   result.Limit,
		HasMore: result.HasMore,
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*entities.User, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	return r.AuthUseCase.GetCurrentUser(ctx, userID)
}

// LibraryCourse is the resolver for the libraryCourse field.
func (r *queryResolver) LibraryCourse(ctx context.Context, id string) (*entities.LibraryCourse, error) {
	return r.LibraryCourseRepo.GetByID(ctx, id)
}

// LibraryCourses is the resolver for the libraryCourses field.
func (r *queryResolver) LibraryCourses(ctx context.Context, pagination *PaginationInput, difficulty *entities.Difficulty) (*LibraryCourseConnection, error) {
	page, limit := 1, 20
	if pagination != nil {
		if pagination.Page != nil {
			page = *pagination.Page
		}
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
	}
	offset := (page - 1) * limit

	var courses []*entities.LibraryCourse
	var total int
	var err error

	if difficulty != nil {
		courses, total, err = r.LibraryCourseRepo.ListByDifficulty(ctx, *difficulty, limit, offset)
	} else {
		courses, total, err = r.LibraryCourseRepo.List(ctx, limit, offset)
	}

	if err != nil {
		return nil, err
	}

	return &LibraryCourseConnection{
		Courses: courses,
		Total:   total,
		Page:    page,
		Limit:   limit,
		HasMore: offset+len(courses) < total,
	}, nil
}

// SearchLibraryCourses is the resolver for the searchLibraryCourses field.
func (r *queryResolver) SearchLibraryCourses(ctx context.Context, query string, pagination *PaginationInput) (*LibraryCourseConnection, error) {
	page, limit := 1, 20
	if pagination != nil {
		if pagination.Page != nil {
			page = *pagination.Page
		}
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
	}
	offset := (page - 1) * limit

	courses, total, err := r.LibraryCourseRepo.Search(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}

	return &LibraryCourseConnection{
		Courses: courses,
		Total:   total,
		Page:    page,
		Limit:   limit,
		HasMore: offset+len(courses) < total,
	}, nil
}

// MyAuthoredCourses is the resolver for the myAuthoredCourses field.
func (r *queryResolver) MyAuthoredCourses(ctx context.Context, pagination *PaginationInput) (*LibraryCourseConnection, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	page, limit := 1, 20
	if pagination != nil {
		if pagination.Page != nil {
			page = *pagination.Page
		}
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
	}
	offset := (page - 1) * limit

	courses, total, err := r.LibraryCourseRepo.GetByAuthorID(ctx, userID, limit, offset)
	if err != nil {
		return nil, err
	}

	return &LibraryCourseConnection{
		Courses: courses,
		Total:   total,
		Page:    page,
		Limit:   limit,
		HasMore: offset+len(courses) < total,
	}, nil
}

// CoursesByTag is the resolver for the coursesByTag field.
func (r *queryResolver) CoursesByTag(ctx context.Context, tag string, pagination *PaginationInput) (*LibraryCourseConnection, error) {
	page, limit := 1, 20
	if pagination != nil {
		if pagination.Page != nil {
			page = *pagination.Page
		}
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
	}
	offset := (page - 1) * limit

	courses, total, err := r.LibraryCourseRepo.GetByTag(ctx, tag, limit, offset)
	if err != nil {
		return nil, err
	}

	return &LibraryCourseConnection{
		Courses: courses,
		Total:   total,
		Page:    page,
		Limit:   limit,
		HasMore: offset+len(courses) < total,
	}, nil
}

// AllTags is the resolver for the allTags field.
func (r *queryResolver) AllTags(ctx context.Context) ([]string, error) {
	return r.LibraryCourseRepo.GetAllTags(ctx)
}

// MyCourses is the resolver for the myCourses field.
func (r *queryResolver) MyCourses(ctx context.Context, pagination *PaginationInput) (*UserCourseConnection, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	page, limit := 1, 20
	if pagination != nil {
		if pagination.Page != nil {
			page = *pagination.Page
		}
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
	}
	offset := (page - 1) * limit

	courses, total, err := r.UserCourseRepo.ListByUser(ctx, userID, limit, offset)
	if err != nil {
		return nil, err
	}

	return &UserCourseConnection{
		Courses: courses,
		Total:   total,
		Page:    page,
		Limit:   limit,
		HasMore: offset+len(courses) < total,
	}, nil
}

// MyCompletedCourses is the resolver for the myCompletedCourses field.
func (r *queryResolver) MyCompletedCourses(ctx context.Context, pagination *PaginationInput) (*UserCourseConnection, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	page, limit := 1, 20
	if pagination != nil {
		if pagination.Page != nil {
			page = *pagination.Page
		}
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
	}
	offset := (page - 1) * limit

	courses, total, err := r.UserCourseRepo.ListCompleted(ctx, userID, limit, offset)
	if err != nil {
		return nil, err
	}

	return &UserCourseConnection{
		Courses: courses,
		Total:   total,
		Page:    page,
		Limit:   limit,
		HasMore: offset+len(courses) < total,
	}, nil
}

// MyInProgressCourses is the resolver for the myInProgressCourses field.
func (r *queryResolver) MyInProgressCourses(ctx context.Context, pagination *PaginationInput) (*UserCourseConnection, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	page, limit := 1, 20
	if pagination != nil {
		if pagination.Page != nil {
			page = *pagination.Page
		}
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
	}
	offset := (page - 1) * limit

	courses, total, err := r.UserCourseRepo.ListInProgress(ctx, userID, limit, offset)
	if err != nil {
		return nil, err
	}

	return &UserCourseConnection{
		Courses: courses,
		Total:   total,
		Page:    page,
		Limit:   limit,
		HasMore: offset+len(courses) < total,
	}, nil
}

// UserCourse is the resolver for the userCourse field.
func (r *queryResolver) UserCourse(ctx context.Context, id string) (*entities.UserCourse, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	userCourse, err := r.UserCourseRepo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	// Verify ownership
	if userCourse.UserID != userID {
		return nil, errors.New("not authorized to view this course")
	}

	return userCourse, nil
}

// MyEnrolledCourses is the resolver for the myEnrolledCourses field.
func (r *queryResolver) MyEnrolledCourses(ctx context.Context) ([]*entities.UserCourse, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	// Get all courses for user (no pagination, return all)
	courses, _, err := r.UserCourseRepo.ListByUser(ctx, userID, 1000, 0)
	if err != nil {
		return nil, err
	}

	return courses, nil
}

// GetUserCourseByLibraryCourse is the resolver for the getUserCourseByLibraryCourse field.
func (r *queryResolver) GetUserCourseByLibraryCourse(ctx context.Context, libraryCourseID string) (*entities.UserCourse, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	userCourse, err := r.UserCourseRepo.GetByUserAndCourse(ctx, userID, libraryCourseID)
	if err != nil {
		return nil, err
	}

	// Verify ownership
	if userCourse.UserID != userID {
		return nil, errors.New("not authorized to view this course")
	}

	return userCourse, nil
}

// MyBookmarks is the resolver for the myBookmarks field.
func (r *queryResolver) MyBookmarks(ctx context.Context) ([]*entities.Bookmark, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	return r.BookmarkRepo.GetByUserID(ctx, userID)
}

// CourseBookmarks is the resolver for the courseBookmarks field.
func (r *queryResolver) CourseBookmarks(ctx context.Context, libraryCourseID string) ([]*entities.Bookmark, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	return r.BookmarkRepo.GetByCourse(ctx, userID, libraryCourseID)
}

// CourseAnalytics is the resolver for the courseAnalytics field.
func (r *queryResolver) CourseAnalytics(ctx context.Context, libraryCourseID string) (*entities.CourseAnalytics, error) {
	return r.AnalyticsRepo.GetCourseAnalytics(ctx, libraryCourseID)
}

// MyAuthoredCoursesAnalytics is the resolver for the myAuthoredCoursesAnalytics field.
func (r *queryResolver) MyAuthoredCoursesAnalytics(ctx context.Context) ([]*entities.CourseAnalytics, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	return r.AnalyticsRepo.GetAuthorCoursesAnalytics(ctx, userID)
}

// LessonAttachments is the resolver for the lessonAttachments field.
func (r *queryResolver) LessonAttachments(ctx context.Context, libraryCourseID string, lessonIndex int) ([]*entities.Attachment, error) {
	return r.AttachmentRepo.ListByLesson(ctx, libraryCourseID, lessonIndex)
}

// QuizStats is the resolver for the quizStats field.
func (r *queryResolver) QuizStats(ctx context.Context, courseID string, quizID string) (*entities.QuizStats, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	return r.QuizRepo.GetQuizStats(ctx, userID, courseID, quizID)
}

// CourseQuizSummary is the resolver for the courseQuizSummary field.
func (r *queryResolver) CourseQuizSummary(ctx context.Context, courseID string) (*entities.CourseQuizSummary, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	return r.QuizRepo.GetCourseQuizSummary(ctx, userID, courseID)
}

// DashboardQuizStats is the resolver for the dashboardQuizStats field.
func (r *queryResolver) DashboardQuizStats(ctx context.Context, fromDate *string, toDate *string) (*entities.DashboardQuizStats, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	var from, to *time.Time
	if fromDate != nil {
		parsed, err := time.Parse("2006-01-02", *fromDate)
		if err == nil {
			from = &parsed
		}
	}
	if toDate != nil {
		parsed, err := time.Parse("2006-01-02", *toDate)
		if err == nil {
			to = &parsed
		}
	}

	return r.QuizRepo.GetDashboardQuizStats(ctx, userID, from, to)
}

// ReviewQueue is the resolver for the reviewQueue field.
func (r *queryResolver) ReviewQueue(ctx context.Context, courseID string, limit *int) ([]*entities.ReviewQueueItem, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	queryLimit := 10
	if limit != nil {
		queryLimit = *limit
	}

	items, err := r.QuizRepo.GetReviewQueue(ctx, userID, courseID, queryLimit)
	if err != nil {
		return nil, err
	}

	// Convert to pointers
	result := make([]*entities.ReviewQueueItem, len(items))
	for i := range items {
		result[i] = &items[i]
	}

	return result, nil
}

// UserAnswer is the resolver for the userAnswer field.
func (r *quizResponseResolver) UserAnswer(ctx context.Context, obj *entities.QuizResponse) (string, error) {
	return string(obj.UserAnswer), nil
}

// TimeTakenSeconds is the resolver for the timeTakenSeconds field.
func (r *quizResponseResolver) TimeTakenSeconds(ctx context.Context, obj *entities.QuizResponse) (*int, error) {
	if obj.TimeTakenSec == 0 {
		return nil, nil
	}
	return &obj.TimeTakenSec, nil
}

// LibraryCourse is the resolver for the libraryCourse field on UserCourse.
func (r *userCourseResolver) LibraryCourse(ctx context.Context, obj *entities.UserCourse) (*entities.LibraryCourse, error) {
	return r.LibraryCourseRepo.GetByID(ctx, obj.LibraryCourseID)
}

// Attachment returns AttachmentResolver implementation.
func (r *Resolver) Attachment() AttachmentResolver { return &attachmentResolver{r} }

// Lesson returns LessonResolver implementation.
func (r *Resolver) Lesson() LessonResolver { return &lessonResolver{r} }

// LibraryCourse returns LibraryCourseResolver implementation.
func (r *Resolver) LibraryCourse() LibraryCourseResolver { return &libraryCourseResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// QuizResponse returns QuizResponseResolver implementation.
func (r *Resolver) QuizResponse() QuizResponseResolver { return &quizResponseResolver{r} }

// UserCourse returns UserCourseResolver implementation.
func (r *Resolver) UserCourse() UserCourseResolver { return &userCourseResolver{r} }

type attachmentResolver struct{ *Resolver }
type lessonResolver struct{ *Resolver }
type libraryCourseResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type quizResponseResolver struct{ *Resolver }
type userCourseResolver struct{ *Resolver }
