package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"errors"

	httpAdapter "github.com/project/backend/adapters/http"
	"github.com/project/backend/application/ports"
	"github.com/project/backend/domain/entities"
)

// CreateUser creates a new user
func (r *mutationResolver) CreateUser(ctx context.Context, input CreateUserInput) (*entities.User, error) {
	return r.UserUseCase.CreateUser(ctx, ports.CreateUserInput{
		Email:    input.Email,
		Name:     input.Name,
		Password: input.Password,
	})
}

// UpdateUser updates an existing user
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input UpdateUserInput) (*entities.User, error) {
	return r.UserUseCase.UpdateUser(ctx, id, ports.UpdateUserInput{
		Name:  input.Name,
		Email: input.Email,
	})
}

// DeleteUser deletes a user
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	err := r.UserUseCase.DeleteUser(ctx, id)
	return err == nil, err
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input RegisterInput) (*AuthPayload, error) {
	result, err := r.AuthUseCase.Register(ctx, ports.RegisterInput{
		Email:    input.Email,
		Name:     input.Name,
		Password: input.Password,
	})
	if err != nil {
		return nil, err
	}

	return &AuthPayload{
		User:         result.User,
		AccessToken:  result.AccessToken,
		RefreshToken: result.RefreshToken,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input LoginInput) (*AuthPayload, error) {
	result, err := r.AuthUseCase.Login(ctx, ports.LoginInput{
		Email:    input.Email,
		Password: input.Password,
	})
	if err != nil {
		return nil, err
	}

	return &AuthPayload{
		User:         result.User,
		AccessToken:  result.AccessToken,
		RefreshToken: result.RefreshToken,
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*TokenPayload, error) {
	result, err := r.AuthUseCase.RefreshToken(ctx, refreshToken)
	if err != nil {
		return nil, err
	}

	return &TokenPayload{
		AccessToken:  result.AccessToken,
		RefreshToken: result.RefreshToken,
	}, nil
}

// User returns a single user by ID
func (r *queryResolver) User(ctx context.Context, id string) (*entities.User, error) {
	return r.UserUseCase.GetUser(ctx, id)
}

// Users returns a paginated list of users
func (r *queryResolver) Users(ctx context.Context, pagination *PaginationInput) (*UserConnection, error) {
	input := ports.PaginationInput{Page: 1, Limit: 20}
	if pagination != nil {
		if pagination.Page != nil {
			input.Page = *pagination.Page
		}
		if pagination.Limit != nil {
			input.Limit = *pagination.Limit
		}
	}

	result, err := r.UserUseCase.ListUsers(ctx, input)
	if err != nil {
		return nil, err
	}

	return &UserConnection{
		Users:   result.Users,
		Total:   result.Total,
		Page:    result.Page,
		Limit:   result.Limit,
		HasMore: result.HasMore,
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*entities.User, error) {
	userID := httpAdapter.GetUserIDFromContext(ctx)
	if userID == "" {
		return nil, errors.New("authentication required")
	}

	return r.AuthUseCase.GetCurrentUser(ctx, userID)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *userConnectionResolver) Users(ctx context.Context, obj *UserConnection) ([]*entities.User, error) {
	return obj.Users, nil
}
func (r *Resolver) UserConnection() UserConnectionResolver { return &userConnectionResolver{r} }
type userConnectionResolver struct{ *Resolver }
*/
